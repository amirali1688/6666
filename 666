# Copilot Bot with Invite, Points, Persistent Memory & Support Reply â­
import os
import re
import time
import json
import random
import requests
from datetime import datetime
from bs4 import BeautifulSoup
import pytz

# ğŸ” Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒ Ø±Ø¨Ø§Øª
TOKEN = os.getenv("RUBIKA_BOT_TOKEN", "BAJHE0KWHIMGWENTXWDZTDZWOQYPWHARVSCMANQKAIJKPVPAFMPFGVWBRCTRLNEQ")  # â† ØªÙˆÚ©Ù† ÙˆØ§Ù‚Ø¹ÛŒ Ø±Ø§ Ø§ÛŒÙ†Ø¬Ø§ ÛŒØ§ Ø¯Ø± env Ø¨Ú¯Ø°Ø§Ø±
BOT_USERNAME = "AI_chat_bot"
BASE_URL = f"https://botapi.rubika.ir/v3/{TOKEN}/"

# ğŸ—‚ ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡â€ŒØ³Ø§Ø²ÛŒ
POEMS_FILE = "hafez_poems.json"
MEMORY_FILE = "memory.json"
POINTS_FILE = "points.json"

# ğŸ‘‘ Ø´Ù†Ø§Ø³Ù‡â€ŒÛŒ Ù…Ø§Ù„Ú©
OWNER_ID = "b0IJu3T0Cwu0fbdc343cba54e43d2064"

# ğŸ—„ Ø­Ø§ÙØ¸Ù‡ Ø¯Ø± Ø²Ù…Ø§Ù† Ø§Ø¬Ø±Ø§ (Ù¾Ø³ Ø§Ø² Ù„ÙˆØ¯ Ø§Ø² Ø¯ÛŒØ³Ú©)
memory = {}       # { user_id: {"name","mood","msgs","owner_greeted","support_mode"} }
points_data = {}  # { user_id: {"score","invited_by"} }

# ğŸ§© Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ù¾Ù†Ù„
panel_options = {
    "1": "ğŸ”§ Ù…Ø¯ÛŒØ±ÛŒØª Ø±Ø¨Ø§Øª ÙØ¹Ø§Ù„ Ø´Ø¯. Ù…Ù†ØªØ¸Ø± Ø¯Ø³ØªÙˆØ±Ø§ØªØª Ù‡Ø³ØªÙ…!",
    "2": "ğŸ’° Ù…ÙˆØ¬ÙˆØ¯ÛŒ Ø´Ù…Ø§: Û° Ø§Ø¹ØªØ¨Ø§Ø±. Ø¨Ø±Ø§ÛŒ Ø´Ø§Ø±Ú˜ØŒ Ø¹Ø¯Ø¯ 5 Ø±Ùˆ Ø¨Ø²Ù†.",
    "3": "ğŸ“… Ø§Ø´ØªØ±Ø§Ú© ÙØ¹Ù„ÛŒ: Ø±Ø§ÛŒÚ¯Ø§Ù†. Ø¨Ø±Ø§ÛŒ Ø§Ø±ØªÙ‚Ø§Ø¡ØŒ Ø¹Ø¯Ø¯ 6 Ø±Ùˆ Ø¨ÙØ±Ø³Øª.",
    "4": "ğŸ“œ Ø¯Ø±ÛŒØ§ÙØª ÙØ§Ù„ Ø­Ø§ÙØ¸. Â«ÙØ§Ù„Â» Ø¨Ù†ÙˆÛŒØ³.",
    "5": "ğŸ”‹ Ø´Ø§Ø±Ú˜ Ø§Ø¹ØªØ¨Ø§Ø±: ÙØ¹Ù„Ø§Ù‹ ØºÛŒØ±ÙØ¹Ø§Ù„ØŒ Ø¨Ù‡ Ø²ÙˆØ¯ÛŒ Ù…ÛŒØ§Ø¯!",
    "6": "ğŸ›’ Ø§Ø´ØªØ±Ø§Ú© ÙˆÛŒÚ˜Ù‡ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª. Ø¨Ø²ÙˆØ¯ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ù…ÛŒØ´Ù‡!",
    "7": "ğŸ” Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø­Ø³Ø§Ø¨.",
    "8": "ğŸ§‘â€ğŸ’» Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ: Ù¾ÛŒØ§Ù… Ø¨ÙØ±Ø³ØªØŒ Ù¾Ø§Ø³Ø® Ù…ÛŒâ€ŒØ¯ÛŒÙ….",
    "9": "ğŸ“¨ Ø¯Ø¹ÙˆØª Ø§Ø² Ø¯ÙˆØ³ØªØ§Ù† - Ø¯Ø±ÛŒØ§ÙØª Ù„ÛŒÙ†Ú© Ø¯Ø¹ÙˆØª Ùˆ Ø§Ù…ØªÛŒØ§Ø²",
    "10": "ğŸ§© Ú†ÛŒØ³ØªØ§Ù† - Ù…Ø¹Ù…Ø§Ù‡Ø§ÛŒ Ø¬Ø§Ù„Ø¨ Ùˆ Ø³Ø±Ú¯Ø±Ù… Ú©Ù†Ù†Ø¯Ù‡"
}

# ğŸ² Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ú†ÛŒØ³ØªØ§Ù†â€ŒÙ‡Ø§
RIDDLES = [
    {
        "question": "Ú†ÛŒØ³Øª Ø¢Ù† Ú©Ù‡ Ø±ÙˆØ² Ù…ÛŒâ€ŒØ¨ÛŒÙ†ÛŒÙ… Ùˆ Ø´Ø¨ Ù†Ø§Ù¾Ø¯ÛŒØ¯ Ù…ÛŒâ€ŒØ´ÙˆØ¯ØŸ",
        "answer": "Ø®ÙˆØ±Ø´ÛŒØ¯",
        "hint": "Ù…Ù†Ø¨Ø¹ Ù†ÙˆØ± Ùˆ Ú¯Ø±Ù…Ø§ÛŒ Ø²Ù…ÛŒÙ†"
    },
    {
        "question": "Ø®Ø§Ù†Ù‡â€ŒØ§ÛŒ Ø¯Ø§Ø±Ù… Ø¨Ø¯ÙˆÙ† Ø¯Ø± Ùˆ Ù¾Ù†Ø¬Ø±Ù‡ØŒ Ø³Ø§Ú©Ù†Ø§Ù†Ù… Ø¨ÛŒâ€ŒØ¹Ø¯Ø¯ Ùˆ Ø¨ÛŒâ€ŒØ­Ø³Ø§Ø¨ØŒ Ú†ÛŒØ³ØªØŸ",
        "answer": "Ù…Ø§Ù‡ÛŒâ€ŒÙ‡Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§",
        "hint": "Ù…Ø­ÛŒØ·ÛŒ Ø¢Ø¨ÛŒ Ø¨Ø§ Ù…ÙˆØ¬ÙˆØ¯Ø§Øª ÙØ±Ø§ÙˆØ§Ù†"
    },
    {
        "question": "Ø§Ø² Ú©ÙˆÙ‡ Ø¨Ø§Ù„Ø§ Ù…ÛŒâ€ŒØ±ÙˆØ¯ØŒ Ø§Ø² Ú©ÙˆÙ‡ Ù¾Ø§ÛŒÛŒÙ† Ù…ÛŒâ€ŒØ¢ÛŒØ¯ØŒ Ø§Ù…Ø§ Ø§Ø² Ø¬Ø§ÛŒ Ø®ÙˆØ¯ ØªÚ©Ø§Ù† Ù†Ù…ÛŒâ€ŒØ®ÙˆØ±Ø¯. Ú†ÛŒØ³ØªØŸ",
        "answer": "Ø¬Ø§Ø¯Ù‡",
        "hint": "ÙˆØ³ÛŒÙ„Ù‡ Ø§Ø±ØªØ¨Ø§Ø·ÛŒ Ø¨ÛŒÙ† Ø´Ù‡Ø±Ù‡Ø§"
    },
    {
        "question": "Ù‡Ù…Ù‡ Ø¢Ù† Ø±Ø§ Ø¯Ø§Ø±Ù†Ø¯ØŒ ÙˆÙ„ÛŒ Ù‡ÛŒÚ†Ú©Ø³ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†Ø¯ Ø¢Ù† Ø±Ø§ Ø¨Ø¯Ù‡Ø¯. Ú†ÛŒØ³ØªØŸ",
        "answer": "Ø³Ù†",
        "hint": "Ø¨Ø§ Ú¯Ø°Ø´Øª Ø²Ù…Ø§Ù† Ø§ÙØ²Ø§ÛŒØ´ Ù…ÛŒâ€ŒÛŒØ§Ø¨Ø¯"
    },
    {
        "question": "Ù‡Ø± Ú†Ù‡ Ø¨ÛŒØ´ØªØ± Ø¨Ú¯ÛŒØ±Ù…ØŒ Ø¨ÛŒØ´ØªØ± Ø¨Ø§Ù‚ÛŒ Ù…ÛŒâ€ŒÙ…Ø§Ù†Ø¯. Ú†ÛŒØ³ØªØŸ",
        "answer": "Ø¹Ú©Ø³",
        "hint": "Ø«Ø¨Øª Ù„Ø­Ø¸Ø§Øª"
    },
    {
        "question": "Ø¯Ø§Ø±Ø§ÛŒ Ø´Ù‡Ø± Ù‡Ø³Øª Ø§Ù…Ø§ Ø®Ø§Ù†Ù‡ Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø¯Ø§Ø±Ø§ÛŒ Ø¬Ù†Ú¯Ù„ Ø§Ø³Øª Ø§Ù…Ø§ Ø¯Ø±Ø®Øª Ù†Ø¯Ø§Ø±Ø¯ØŒ Ø¯Ø§Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ Ø§Ø³Øª Ø§Ù…Ø§ Ø¢Ø¨ Ù†Ø¯Ø§Ø±Ø¯. Ú†ÛŒØ³ØªØŸ",
        "answer": "Ù†Ù‚Ø´Ù‡",
        "hint": "Ø¨Ø±Ø§ÛŒ Ù…Ø³ÛŒØ±ÛŒØ§Ø¨ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯"
    },
    {
        "question": "Ù‡Ù…Ù‡ Ù…Ø±Ø§ Ù…ÛŒâ€ŒØ¨ÛŒÙ†Ù†Ø¯ØŒ Ø§Ù…Ø§ Ù‡ÛŒÚ†Ú©Ø³ Ù…Ø±Ø§ Ù„Ù…Ø³ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯. Ø§Ú¯Ø± Ù†Ø§Ù…Ù… Ø±Ø§ Ø¨Ú¯ÙˆÛŒÛŒØŒ Ù†Ø§Ù¾Ø¯ÛŒØ¯ Ù…ÛŒâ€ŒØ´ÙˆÙ…. Ú†ÛŒØ³ØªÙ…ØŸ",
        "answer": "Ø³Ú©ÙˆØª",
        "hint": "Ø¯Ø± ØºÛŒØ§Ø¨ ØµØ¯Ø§ Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒØ´ÙˆØ¯"
    },
    {
        "question": "Ø§Ø² Ø¢Ø¨ Ø²Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ…ØŒ Ø§Ù…Ø§ Ø§Ú¯Ø± Ø¯Ø± Ø¢Ø¨ Ø¨ÛŒÙØªÙ… Ù…ÛŒâ€ŒÙ…ÛŒØ±Ù…. Ú†ÛŒØ³ØªÙ…ØŸ",
        "answer": "Ù†Ù…Ú©",
        "hint": "Ø¨Ø±Ø§ÛŒ Ø·Ø¹Ù… Ø¯Ø§Ø¯Ù† Ø¨Ù‡ ØºØ°Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯"
    },
    {
        "question": "Ù¾Ø± Ø§Ø³Øª Ø§Ø² Ø³ÙˆØ±Ø§Ø® Ø§Ù…Ø§ Ù‡Ù†ÙˆØ² Ø¢Ø¨ Ø±Ø§ Ù†Ú¯Ù‡ Ù…ÛŒâ€ŒØ¯Ø§Ø±Ø¯. Ú†ÛŒØ³ØªØŸ",
        "answer": "Ø§Ø³ÙÙ†Ø¬",
        "hint": "Ø¨Ø±Ø§ÛŒ Ø´Ø³ØªØ´Ùˆ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯"
    },
    {
        "question": "Ù‡Ø± Ú†Ù‡ Ø¨ÛŒØ´ØªØ± Ø§Ø² Ø¢Ù† Ø¨Ø±Ø¯Ø§Ø±ÛŒØ¯ØŒ Ø¨Ø²Ø±Ú¯ØªØ± Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ú†ÛŒØ³ØªØŸ",
        "answer": "Ú†Ø§Ù„Ù‡",
        "hint": "Ø¯Ø± Ø²Ù…ÛŒÙ† Ø§ÛŒØ¬Ø§Ø¯ Ù…ÛŒâ€ŒØ´ÙˆØ¯"
    }
]

# â€”â€”â€”â€”â€” Utilities: persistent storage â€”â€”â€”â€”â€”

def load_json(path, default):
    try:
        if os.path.exists(path):
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
    except:
        pass
    return default

def save_json(path, data):
    try:
        tmp = path + ".tmp"
        with open(tmp, "w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        os.replace(tmp, path)
    except:
        pass

# â€”â€”â€”â€”â€” Poems cache â€”â€”â€”â€”â€”

def load_cached_poems():
    if os.path.exists(POEMS_FILE):
        with open(POEMS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return None

def save_cached_poems(poems):
    with open(POEMS_FILE, "w", encoding="utf-8") as f:
        json.dump(poems, f, ensure_ascii=False, indent=2)

def fetch_hafez_poems():
    cached = load_cached_poems()
    if cached:
        return cached
    poems, headers = [], {"User-Agent": "Mozilla/5.0"}
    try:
        res = requests.get("https://ganjoor.net/hafez/ghazal", headers=headers, timeout=10)
        soup = BeautifulSoup(res.text, "html.parser")
        links = soup.find_all("a", href=re.compile(r"^/hafez/ghazal/"))
        for a in links[:60]:  # Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø¨Ø±Ø§ÛŒ Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² ÙØ´Ø§Ø± Ø²ÛŒØ§Ø¯
            try:
                p = requests.get("https://ganjoor.net" + a["href"], headers=headers, timeout=10)
                sp = BeautifulSoup(p.text, "html.parser")
                div = sp.select_one("div.poem")
                if div:
                    poems.append(div.get_text("\n", strip=True))
                time.sleep(0.25)
            except:
                pass
    except:
        pass
    if not poems:
        poems = [
            "Ø§Ù„Ø§ ÛŒØ§ Ø§ÛŒÙ‡Ø§ Ø§Ù„Ø³Ø§Ù‚ÛŒ Ø§Ø¯Ø± Ú©Ø§Ø³Ø§Ù‹ Ùˆ Ù†Ø§ÙˆÙ„Ù‡Ø§\nÚ©Ù‡ Ø¹Ø´Ù‚ Ø¢Ø³Ø§Ù† Ù†Ù…ÙˆØ¯ Ø§ÙˆÙ„ ÙˆÙ„ÛŒ Ø§ÙØªØ§Ø¯ Ù…Ø´Ú©Ù„â€ŒÙ‡Ø§",
            "Ø¯ÙˆØ´ Ø¯ÛŒØ¯Ù… Ú©Ù‡ Ù…Ù„Ø§Ø¦Ú© Ø¯Ø± Ù…ÛŒØ®Ø§Ù†Ù‡ Ø²Ø¯Ù†Ø¯\nÚ¯Ù„ Ø¢Ø¯Ù… Ø¨Ø³Ø±Ø´ØªÙ†Ø¯ Ùˆ Ø¨Ù‡ Ù¾ÛŒÙ…Ø§Ù†Ù‡ Ø²Ø¯Ù†Ø¯"
        ]
    save_cached_poems(poems)
    return poems

# â€”â€”â€”â€”â€” Helpers â€”â€”â€”â€”â€”

def get_time_greeting():
    now = datetime.now(pytz.timezone("Asia/Tehran"))
    h, wd = now.hour, now.weekday()
    if 6 <= h < 12: g = "ØµØ¨Ø­ Ø¨Ø®ÛŒØ± â˜€ï¸"
    elif 12 <= h < 18: g = "Ø¸Ù‡Ø± Ø¨Ø®ÛŒØ± â˜•"
    elif 18 <= h < 23: g = "Ø´Ø¨ Ø¨Ø®ÛŒØ± âœ¨"
    else: g = "Ù†ÛŒÙ…Ù‡â€ŒØ´Ø¨ Ø¨Ø®ÛŒØ± ğŸŒ™"
    if wd == 4: g += " ÙØ±Ø¯Ø§ Ø¬Ù…Ø¹Ù‡â€ŒØ³Øª! ğŸ˜Œ"
    elif wd == 5: g += " Ø¬Ù…Ø¹Ù‡â€ŒØ³Øª! Ø§Ø³ØªØ±Ø§Ø­Øª Ú©Ù† ğŸ˜Š"
    return g

def get_updates(offset_id=None, limit=50):
    params = {"limit": limit}
    if offset_id: params["offset_id"] = offset_id
    try:
        r = requests.post(BASE_URL + "getUpdates", json=params, timeout=10)
        data = r.json().get("data", {})
        return data.get("updates", []), data.get("next_offset_id")
    except:
        return [], None

def send_message(chat_id, text):
    try:
        return requests.post(
            BASE_URL + "sendMessage",
            json={"chat_id": chat_id, "text": text},
            timeout=10
        ).status_code == 200
    except:
        return False

# â€”â€”â€”â€”â€” Core logic â€”â€”â€”â€”â€”

def copilot_response(text, user_id, poems):
    text_raw = text or ""
    text = text_raw.strip().lower()
    greet = get_time_greeting()

    # init user memory & points
    if user_id not in memory:
        memory[user_id] = {
            "name": "Ø¯ÙˆØ³Øª Ù…Ù†",
            "mood": "neutral",
            "msgs": 0,
            "owner_greeted": False,
            "support_mode": False,
            "current_riddle": None
        }
    if user_id not in points_data:
        points_data[user_id] = {"score": 0, "invited_by": None}

    # one-time owner welcome
    if user_id == OWNER_ID and not memory[user_id]["owner_greeted"]:
        memory[user_id]["owner_greeted"] = True
        return "ğŸ‘‘ Ø³Ù„Ø§Ù… Ø§Ù…ÛŒØ±Ø¹Ù„ÛŒ Ø¹Ø²ÛŒØ²! Ø´Ù…Ø§ Ù…Ø§Ù„Ú© Ø§ÛŒÙ† Ø±Ø¨Ø§Øª Ù‡Ø³ØªÛŒØ¯. Ú†Ù‡ Ø®Ø¯Ù…ØªÛŒ Ø§Ø² Ø¯Ø³Øª Ù…Ù† Ø¨Ø±Ù…ÛŒØ§Ø¯ØŸ"

    user = memory[user_id]
    user["msgs"] += 1
    name, mood = user["name"], user["mood"]
    score = points_data[user_id]["score"]

    # support mode: forward user msgs to owner
    if user["support_mode"]:
        if text in ("Ø®Ø±ÙˆØ¬", "Ø¨Ø±Ú¯Ø´Øª", "Ù…Ù†Ùˆ"):
            user["support_mode"] = False
            return "ğŸ”™ Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ Ø¨Ø±Ú¯Ø´ØªÛŒØ¯!"
        send_message(OWNER_ID, f"ğŸ“© Ù¾ÛŒØ§Ù… Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² {name} ({user_id}):\n\n{text_raw}")
        return "âœ… Ù¾ÛŒØ§Ù… Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯. Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ Â«Ø®Ø±ÙˆØ¬Â» Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯."

    # mood detection
    if any(w in text for w in ["Ø®Ø³ØªÙ‡", "Ù†Ø§Ø±Ø§Ø­Øª", "ØºÙ…", "Ù†Ø§Ø§Ù…ÛŒØ¯"]):
        user["mood"] = "sad"
    elif any(w in text for w in ["Ø®ÙˆØ´Ø­Ø§Ù„", "Ø¨Ø§Ø­Ø§Ù„", "Ø¹Ø§Ù„ÛŒ", "Ø®ÙˆØ¨Ù‡"]):
        user["mood"] = "happy"

    # set name
    if text.startswith("Ø§Ø³Ù… Ù…Ù†"):
        parts = text_raw.strip().split()
        if len(parts) >= 3:
            user["name"] = parts[-1].strip()
            return f"ğŸ‰ Ø³Ù„Ø§Ù… {user['name']}! Ø§Ø² Ø§ÛŒÙ† Ø¨Ù‡ Ø¨Ø¹Ø¯ Ø§ÛŒÙ†Ø·ÙˆØ±ÛŒ ØµØ¯Ø§Øª Ù…ÛŒâ€ŒÚ©Ù†Ù…."
        return "Ù„Ø·ÙØ§Ù‹ Ø¨Ù†ÙˆÛŒØ³ Â«Ø§Ø³Ù… Ù…Ù† [Ù†Ø§Ù…]Â»."

    # invite link
    if text in ("9", "Ø¯Ø¹ÙˆØª", "ğŸ“¨"):
        link = f"https://rubika.ir/{BOT_USERNAME}?start={user_id}"
        return (
            f"ğŸ“¨ {name} Ø¹Ø²ÛŒØ²! Ù„ÛŒÙ†Ú© Ø¯Ø¹ÙˆØª ØªÙˆ:\n{link}\n\n"
            f"Ù‡Ø± Ú©Ø³ÛŒ Ø¨Ø§ Ø§ÛŒÙ† Ù„ÛŒÙ†Ú© Ø¨ÛŒØ§Ø¯ØŒ Ù‡Ø± Ø¯Ùˆ Û± Ø§Ù…ØªÛŒØ§Ø² Ù…ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ†!\n"
            f"Ø§Ù…ØªÛŒØ§Ø² Ø´Ù…Ø§: {score} â­"
        )

    # panel menu
    if text == "Ù¾Ù†Ù„":
        items = []
        for k, v in panel_options.items():
            parts = v.split()
            if len(parts) >= 2:
                emoji = parts[0]
                label = parts[1]
                rest = " ".join(parts[2:]) if len(parts) > 2 else ""
                items.append(f"{k}ï¸âƒ£ {emoji} {label} - {rest}")
            else:
                items.append(f"{k}ï¸âƒ£ {v}")
        menu = "\n".join(items)
        return f"ğŸ”¸ Ù…Ù†ÙˆÛŒ Ù¾Ù†Ù„:\n\n{menu}\n\nØ¨Ø±Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø¹Ø¯Ø¯ ÛŒØ§ Ù…ØªÙ† Ú¯Ø²ÛŒÙ†Ù‡ Ø±Ùˆ Ø¨ÙØ±Ø³Øª."

    # enter support
    if text in ("8", "Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ", "ğŸ§‘â€ğŸ’»"):
        user["support_mode"] = True
        return (
            "ğŸ“© ÙˆØ§Ø±Ø¯ Ø¨Ø®Ø´ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø´Ø¯ÛŒ.\n"
            "Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§Øª Ø§Ø±Ø³Ø§Ù„ Ù…ÛŒØ´Ù‡ Ø¨Ù‡ Ù…Ø§Ù„Ú©.\n"
            "Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ Â«Ø®Ø±ÙˆØ¬Â» Ø¨Ù†ÙˆÛŒØ³."
        )

    # Ú†ÛŒØ³ØªØ§Ù†
    if "Ú†ÛŒØ³ØªØ§Ù†" in text or text == "10" or "Ù…Ø¹Ù…Ø§" in text:
        riddle = random.choice(RIDDLES)
        user["current_riddle"] = {
            "answer": riddle["answer"],
            "hint_used": False,
            "question": riddle["question"]
        }
        return (
            f"ğŸ¤” Ú†ÛŒØ³ØªØ§Ù†:\n\n{riddle['question']}\n\n"
            "â€¢ Ø¨Ø±Ø§ÛŒ Ù¾Ø§Ø³Ø® Ø¯Ø§Ø¯Ù†ØŒ Ø¬ÙˆØ§Ø¨ Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù†ÙˆÛŒØ³\n"
            "â€¢ Ø¨Ø±Ø§ÛŒ Ø±Ø§Ù‡Ù†Ù…Ø§ Ø¨Ù†ÙˆÛŒØ³ Â«Ø±Ø§Ù‡Ù†Ù…Ø§Â»\n"
            "â€¢ Ø§Ú¯Ø± Ù†Ù…ÛŒâ€ŒØ¯Ø§Ù†ÛŒ Ø¨Ù†ÙˆÛŒØ³ Â«Ù†Ù…ÛŒØ¯ÙˆÙ†Ù…Â»\n"
            "â€¢ Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ Ø¨Ù†ÙˆÛŒØ³ Â«Ø®Ø±ÙˆØ¬Â»"
        )
    
    # Ù†Ù…Ø§ÛŒØ´ Ø±Ø§Ù‡Ù†Ù…Ø§
    if text == "Ø±Ø§Ù‡Ù†Ù…Ø§" and user.get("current_riddle"):
        if not user["current_riddle"]["hint_used"]:
            user["current_riddle"]["hint_used"] = True
            hint = next(r["hint"] for r in RIDDLES if r["question"] == user["current_riddle"]["question"])
            return f"ğŸ’¡ Ø±Ø§Ù‡Ù†Ù…Ø§: {hint}\n\nÙ…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒ Ø¬ÙˆØ§Ø¨ Ø±Ø§ Ø¨Ø¨ÛŒÙ†ÛŒØŸ Ø¨Ù†ÙˆÛŒØ³ Â«Ø¬ÙˆØ§Ø¨Â»"
        else:
            return "âš ï¸ Ø´Ù…Ø§ Ù‚Ø¨Ù„Ø§Ù‹ Ø§Ø² Ø±Ø§Ù‡Ù†Ù…Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒØ¯!"

    # Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø§Ø³Ø® Ú†ÛŒØ³ØªØ§Ù†
    if user.get("current_riddle"):
        correct_answer = user["current_riddle"]["answer"].lower()
        
        if text.lower() == correct_answer:
            points = 2 if not user["current_riddle"]["hint_used"] else 1
            points_data[user_id]["score"] += points
            response = (
                f"ğŸ‰ Ø¢ÙØ±ÛŒÙ† {name}! Ù¾Ø§Ø³Ø® Ø´Ù…Ø§ Ø¯Ø±Ø³Øª Ø¨ÙˆØ¯!\n"
                f"Ø§Ù…ØªÛŒØ§Ø² Ø´Ù…Ø§ {'+' + str(points)} â­ (Ø¬Ù…Ø¹: {points_data[user_id]['score']})"
            )
            if user["current_riddle"]["hint_used"]:
                response += "\n(Ø§Ù…ØªÛŒØ§Ø² Ú©Ø§Ù‡Ø´ ÛŒØ§ÙØª Ú†ÙˆÙ† Ø§Ø² Ø±Ø§Ù‡Ù†Ù…Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ø±Ø¯ÛŒ)"
            user.pop("current_riddle")
            return response
            
        elif text == "Ù†Ù…ÛŒØ¯ÙˆÙ†Ù…":
            answer = user.pop("current_riddle")["answer"]
            return f"â˜¹ï¸ Ù¾Ø§Ø³Ø® ØµØ­ÛŒØ­: {answer}\n\nØ¨Ø±Ø§ÛŒ Ú†ÛŒØ³ØªØ§Ù† Ø¬Ø¯ÛŒØ¯ Ø¨Ù†ÙˆÛŒØ³ Â«Ú†ÛŒØ³ØªØ§Ù†Â»"
            
        elif text == "Ø±Ø§Ù‡Ù†Ù…Ø§":
            pass  # Ù‚Ø¨Ù„Ø§Ù‹ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯Ù‡
            
        elif text in ("Ø®Ø±ÙˆØ¬", "Ø¨Ø§Ø²Ú¯Ø´Øª", "Ù…Ù†Ùˆ"):
            user.pop("current_riddle")
            return "ğŸ”™ Ø§Ø² Ø­Ø§Ù„Øª Ú†ÛŒØ³ØªØ§Ù† Ø®Ø§Ø±Ø¬ Ø´Ø¯ÛŒØ¯. Ø¨Ø±Ø§ÛŒ Ø¯ÛŒØ¯Ù† Ù…Ù†Ùˆ Â«Ù¾Ù†Ù„Â» Ø¨Ù†ÙˆÛŒØ³ÛŒØ¯."
            
        else:
            return (
                "Ù¾Ø§Ø³Ø® Ø´Ù…Ø§ Ù†Ø§Ø¯Ø±Ø³Øª Ø§Ø³Øª! Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯:\n"
                "â€¢ Ø¨Ø±Ø§ÛŒ Ø±Ø§Ù‡Ù†Ù…Ø§ Ø¨Ù†ÙˆÛŒØ³ Â«Ø±Ø§Ù‡Ù†Ù…Ø§Â»\n"
                "â€¢ Ø¨Ø±Ø§ÛŒ ØªØ³Ù„ÛŒÙ… Ø´Ø¯Ù† Ø¨Ù†ÙˆÛŒØ³ Â«Ù†Ù…ÛŒØ¯ÙˆÙ†Ù…Â»\n"
                "â€¢ Ø¨Ø±Ø§ÛŒ Ø®Ø±ÙˆØ¬ Ø¨Ù†ÙˆÛŒØ³ Â«Ø®Ø±ÙˆØ¬Â»"
            )

    # other panel options (except invite 9)
    for k, v in panel_options.items():
        if k == "9":
            continue
        parts = v.split()
        emoji = parts[0] if parts else ""
        label = parts[1] if len(parts) > 1 else ""
        if text in (k, emoji, label):
            return f"âœ… {v}"

    # hafez
    if "ÙØ§Ù„ Ø­Ø§ÙØ¸" in text or text == "ÙØ§Ù„":
        poem = random.choice(poems)
        return f"âœ¨ ÙØ§Ù„ Ø­Ø§ÙØ¸ Ø¨Ø±Ø§ÛŒ {name}:\n\n{poem}\n\nğŸ”¹ ØªØ¹Ø¨ÛŒØ±: Ø²Ù†Ø¯Ú¯ÛŒ Ù¾Ø± Ø§Ø² Ø²ÛŒØ¨Ø§ÛŒÛŒâ€ŒØ³Øª."

    # info
    if "Ø§Ø·Ù„Ø§Ø¹Ø§Øª" in text:
        return (
            f"ğŸ“‹ Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø´Ù…Ø§:\n"
            f"â€¢ Ù†Ø§Ù…: {name}\n"
            f"â€¢ Ø´Ù†Ø§Ø³Ù‡: {user_id}\n"
            f"â€¢ Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§: {user['msgs']}\n"
            f"â€¢ Ù…ÙˆØ¯: {user['mood']}\n"
            f"â€¢ Ø§Ù…ØªÛŒØ§Ø²: {score} â­"
        )

    # time & date
    if any(w in text for w in ["Ø³Ø§Ø¹Øª", "ØªØ§Ø±ÛŒØ®", "Ø§Ù…Ø±ÙˆØ²"]):
        now = datetime.now(pytz.timezone("Asia/Tehran"))
        return f"ğŸ“… Ø§Ù…Ø±ÙˆØ² {now.strftime('%Y/%m/%d')}ØŒ Ø³Ø§Ø¹Øª {now.strftime('%H:%M')}."

    # greetings
    if any(w in text for w in ["Ø³Ù„Ø§Ù…", "Ú†Ø·ÙˆØ±ÛŒ", "Ø­Ø§Ù„"]):
        resp = random.choice([
            f"{greet} {name}! Ú†Ù‡ Ø®Ø¨Ø±ØŸ",
            f"Ù‡ÛŒ {name}! Ø®ÙˆØ¨ Ù‡Ø³ØªÛŒØŸ"
        ])
        sugg = random.choice([
            "ğŸ“œ Ø¨Ø±Ø§ÛŒ ÙØ§Ù„ Â«ÙØ§Ù„Â»",
            "ğŸ˜„ Ø¨Ø±Ø§ÛŒ Ø´ÙˆØ®ÛŒ Â«Ø´ÙˆØ®ÛŒÂ»",
            "ğŸ§  Ø¨Ø±Ø§ÛŒ Ø¯Ø§Ù†Ø³ØªÙ†ÛŒ Â«Ø¯Ø§Ù†Ø³ØªÙ†ÛŒÂ»",
            "ğŸ¤” Ø¨Ø±Ø§ÛŒ Ú†ÛŒØ³ØªØ§Ù† Â«Ú†ÛŒØ³ØªØ§Ù†Â»"
        ])
        return f"{resp}\n{sugg}"

    # jokes & trivia & goodbye & mood
    if "Ø´ÙˆØ®ÛŒ" in text:
        return random.choice([
            "ÛŒÙ‡ Ø±ÙˆØ² Ø±Ø¨Ø§Øª Ø¹Ø§Ø´Ù‚ Ø´Ø¯... ÙˆÙ„ÛŒ Ú©Ø±Ø´Ø´ Ø¨Ø§Øª Ø¯ÛŒÚ¯Ù‡â€ŒØ§ÛŒ Ø¨ÙˆØ¯! ğŸ’”",
            "Ø­Ø³Ø§Ø¯Øª Ù†Ø¯Ø§Ø±Ù…... Ù…Ú¯Ø± Ø§ÛŒÙ†Ú©Ù‡ Ø¨Ø§ Ø¨Ø§Øª Ø¯ÛŒÚ¯Ù‡â€ŒØ§ÛŒ ØµØ­Ø¨Øª Ú©Ù†ÛŒ! ğŸ¤–"
        ])
    if "Ø¯Ø§Ù†Ø³ØªÙ†ÛŒ" in text:
        return random.choice([
            "ÙÛŒÙ„â€ŒÙ‡Ø§ Ù†Ù…ÛŒâ€ŒØªÙˆÙ†Ù† Ø¨Ù¾Ø±Ù† ÙˆÙ„ÛŒ Ø­Ø§ÙØ¸Ù‡â€ŒØ´ÙˆÙ† Ø®Ø§Ø±Ù‚â€ŒØ§Ù„Ø¹Ø§Ø¯Ù‡â€ŒØ³Øª! ï¿½",
            "ØºØ±ÙˆØ¨ Ù…Ø±ÛŒØ® Ø¢Ø¨ÛŒÙ‡ØŒ Ù†Ù‡ Ù‚Ø±Ù…Ø²! ğŸš€"
        ])
    if any(w in text for w in ["Ø®Ø¯Ø§Ø­Ø§ÙØ¸", "ÙØ¹Ù„Ø§Ù‹", "Ø¨Ø§ÛŒ"]):
        return f"ÙØ¹Ù„Ø§Ù‹ {name}! Ù…Ù†ØªØ¸Ø±Øª Ù…ÛŒâ€ŒÙ…ÙˆÙ†Ù… ğŸ’¬"
    if user["mood"] == "sad":
        return random.choice([
            f"{greet} {name}... Ù„Ø¨Ø®Ù†Ø¯ Ø¨Ø²Ù†! ğŸ¶",
            "Ù…Ù† Ø§ÛŒÙ†Ø¬Ø§Ù… Ø¨Ø±Ø§ÛŒ Ø­Ø±Ù Ø²Ø¯Ù† ğŸ’™"
        ])

    return f"{name} Ø¬Ø§Ù†ØŒ Ù‡Ø± Ø³ÙˆØ§Ù„ÛŒ Ø¯Ø§Ø´ØªÛŒ Ù…Ù† Ø¯Ø± Ø®Ø¯Ù…ØªÙ…! ğŸ¤"

# â€”â€”â€”â€”â€” Main loop â€”â€”â€”â€”â€”

def main():
    if not TOKEN or TOKEN == "PASTE-YOUR-TOKEN-HERE":
        print("âš ï¸ Ù„Ø·ÙØ§Ù‹ Ù…ØªØºÛŒØ± Ù…Ø­ÛŒØ·ÛŒ RUBIKA_BOT_TOKEN Ø±Ø§ ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯ ÛŒØ§ TOKEN Ø±Ø§ Ø¯Ø± Ú©Ø¯ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ† Ú©Ù†ÛŒØ¯.")
    else:
        print("âœ… ØªÙˆÚ©Ù† Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø´Ø¯.")

    # Ù„ÙˆØ¯ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø¦Ù…ÛŒ
    global memory, points_data
    memory = load_json(MEMORY_FILE, {})
    points_data = load_json(POINTS_FILE, {})

    print("ğŸš€ Ø±Ø¨Ø§Øª Copilot Ø§Ø¬Ø±Ø§ Ø´Ø¯")
    poems = fetch_hafez_poems()
    last_offset = None
    processed = set()
    start_time = time.time()

    while True:
        updates, next_off = get_updates(last_offset)
        for upd in updates:
            if upd.get("type") != "NewMessage":
                continue

            msg = upd.get("new_message", {})
            chat_id = upd.get("chat_id") or msg.get("chat_id")
            if not chat_id:
                continue

            text = (msg.get("text") or "").strip()
            msg_id = str(msg.get("message_id"))
            ts = int(msg.get("time", 0))

            if ts <= start_time or msg_id in processed:
                continue
            processed.add(msg_id)

            user_id = str(chat_id)

            # ğŸ‘‘ Owner reply command
            if user_id == OWNER_ID and text.startswith("/reply "):
                parts = text.split(" ", 2)
                if len(parts) < 3:
                    send_message(chat_id, "â— ÙØ±Ù…Øª: /reply Ø´Ù†Ø§Ø³Ù‡ Ù…ØªÙ† Ù¾Ø§Ø³Ø®")
                else:
                    target, resp = parts[1], parts[2]
                    send_message(target, f"ğŸ“© Ù¾Ø§Ø³Ø® Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ:\n{resp}")
                    send_message(chat_id, "âœ… Ù¾Ø§Ø³Ø® Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.")
                continue

            # Ø«Ø¨Øª Ø¯Ø¹ÙˆØª Ùˆ Ø§Ù…ØªÛŒØ§Ø² Ø§ÙˆÙ„ÛŒÙ† Ù¾ÛŒØ§Ù…
            if user_id not in points_data:
                if text.startswith("/start") and " " in text:
                    inv = text.split(" ", 1)[1].strip()
                    points_data[user_id] = {"score": 1, "invited_by": inv}
                    if inv in points_data:
                        points_data[inv]["score"] = points_data.get(inv, {}).get("score", 0) + 1
                    else:
                        points_data[inv] = {"score": 1, "invited_by": None}
                    save_json(POINTS_FILE, points_data)
                    send_message(chat_id, "ğŸ‰ Ø®ÙˆØ´â€ŒØ§ÙˆÙ…Ø¯ÛŒ! Ù‡Ø± Ø¯Ùˆ Û± Ø§Ù…ØªÛŒØ§Ø² Ú¯Ø±ÙØªÛŒØ¯ â­")
                    continue
                else:
                    points_data[user_id] = {"score": 0, "invited_by": None}
                    save_json(POINTS_FILE, points_data)

            # Ù¾Ø§Ø³Ø® Ù…Ø¹Ù…ÙˆÙ„ÛŒ
            reply = copilot_response(text, user_id, poems)
            send_message(chat_id, reply)

            # Ø°Ø®ÛŒØ±Ù‡ ØªØºÛŒÛŒØ±Ø§Øª Ø­Ø§ÙØ¸Ù‡ Ùˆ Ø§Ù…ØªÛŒØ§Ø²Ù‡Ø§ Ù¾Ø³ Ø§Ø² Ù‡Ø± Ù¾Ø§Ø³Ø®
            save_json(MEMORY_FILE, memory)
            save_json(POINTS_FILE, points_data)

        if next_off and next_off != last_offset:
            last_offset = next_off
        time.sleep(0.5)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("â›”ï¸ Ø±Ø¨Ø§Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯")
